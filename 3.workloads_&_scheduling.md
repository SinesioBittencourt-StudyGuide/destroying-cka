# Understand deployments and how to perform rolling update and rollbacks

Deployment required Fields
- apiVersion
- kind
- metadata
- spec

O Deployment garante que apenas um certo número de Pods estejam down enquanto eles estão sendo atualizados. 
25% max unavailable faz com que apenas 25% possa ficar down, os outros 75% são garantidos de ficar up.
O Deployment também garante que apenas um número específico de Pods possam ser criados acima do número desejado de Pods. 
25% max surge, 125% da capacidade máxima pode ser criado.


Rollback and rollout a deployment

- kubectl create deployment --image=nginx 
- kubectl create -f <yaml_file>
- kubectl rollout status deployment/nginx-deployment
- kubectl get rc
- kubectl get pods
- kubectl describe deployments
- kubectl rollout history deployment.v1.apps/nginx-deployment
- kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause="some nice message here"
- kubectl rollout history deployment.v1.apps/nginx-deployment --revision=2
- kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision=2
- kubectl describe deployment nginx-deployment

[Performing a Rolling Update](https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/)

[Perform a Rollback on a DaemonSet](https://kubernetes.io/docs/tasks/manage-daemon/rollback-daemon-set/)

# Use ConfigMaps and Secrets to configure applications
[Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)

[ConfigMaps](https://kubernetes.io/docs/concepts/configuration/configmap/)
# Know how to scale applications

kubectl scale deployment.v1.apps/nginx-deployment --replicas=10

[ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/)

[Running Multiple Instances of Your App](https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-intro/)

[Horizontal Pod Autoscaler](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)

[Scale a StatefulSet](https://kubernetes.io/docs/tasks/run-application/scale-stateful-set/)

# Understand the primitives used to create robust, self- healing, application deployments

- Deployment
Controller que gerencia o estado dos ReplicaSets e dos Pods dentro dele. Flexibilidade com atualizações e administração.
- ReplicaSet
Orquestra o lifecycle indiviudal de Pods e atualizações.
- DaemonSet
The controller ensures that a single pod, of the same type, runs on every node in the cluster.
A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created.

- StatefulSet
In order to track each Pod as a unique object, the controllers uses an identity composed of stable storage, stable network identity, and an ordinal. This identity remains with the node, regardless of which node the Pod is running on at any one time.


[Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)

[ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/)

[DaemonSet](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/)

[StatefulSet](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)

# Understand how resource limits can affect Pod scheduling

[Kubernetes Scheduler](https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/)

# Awareness of manifest management and common templating tools

[Managing Resources](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/)