# Workloads & Scheduling

## Understand deployments and how to perform rolling update and rollbacks

Deployment required Fields
- apiVersion
- kind
- metadata
- spec

O Deployment garante que apenas um certo número de Pods estejam down enquanto eles estão sendo atualizados.
25% max unavailable faz com que apenas 25% possa ficar down, os outros 75% são garantidos de ficar up.
O Deployment também garante que apenas um número específico de Pods possam ser criados acima do número desejado de Pods.
25% max surge, 125% da capacidade máxima pode ser criado.


Rollback and rollout a deployment

- kubectl create deployment --image=nginx 
- kubectl create -f <yaml_file>
- kubectl rollout status deployment/nginx-deployment
- kubectl get rc
- kubectl get pods
- kubectl describe deployments
- kubectl rollout history deployment.v1.apps/nginx-deployment
- kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause="some nice message here"
- kubectl rollout history deployment.v1.apps/nginx-deployment --revision=2
- kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision=2
- kubectl describe deployment nginx-deployment

[Performing a Rolling Update](https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/)

[Perform a Rollback on a DaemonSet](https://kubernetes.io/docs/tasks/manage-daemon/rollback-daemon-set/)

## Use ConfigMaps and Secrets to configure applications

- ConfigMaps and Secrets are about decoubling data from the Pod that needs them
- ConfigMaps are clear-text, Secrets are base64 encoded
- Different types can be used:
    - Files
    - Directories
    - Literals(Variables)
- All associated data is stored in the ConfigMap or Secret object
- Secrets are mainly used to push variables
- Secrets are used by the k8s cluster itself in order to connect k8s components to one another
kubectl create cm myconfig --from-literal=color=red


Secrets 

k create secret generic secretstuff --from-literal=password=password --from-literal=user=linda

k get secrets secretstuff -o yaml


[Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)

[ConfigMaps](https://kubernetes.io/docs/concepts/configuration/configmap/)

## Know how to scale applications

### Scaling Deployments

kubectl scale deployment.v1.apps/nginx-deployment --replicas=10

### Scaling StatefulSets

kubectl get statefulsets <stateful-set-name>

kubectl scale statefulsets <stateful-set-name> --replicas=<new-replicas>

kubectl apply -f <stateful-set-file-updated>

kubectl edit statefulsets <stateful-set-name>

kubectl patch statefulsets <stateful-set-name> -p '{"spec":{"replicas":<new-replicas>}}'

### Horizontal Pod Autoscaler

Scales the number of Pods based on CPU utilization. Only applied to objects that can be scaled. Implemented as a Kubernetes API resource and a controller.

kubectl get hpa
kubectl describe hpa
kubectl autoscale rs foo --min=2 --max=5 --cpu-percent=80

References:

[Running Multiple Instances of Your App](https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-intro/)

[Horizontal Pod Autoscaler](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)

[Scale a StatefulSet](https://kubernetes.io/docs/tasks/run-application/scale-stateful-set/)

## Understand the primitives used to create robust, self- healing, application deployments

### Deployment

It is a Controller that manages the states of Pods and ReplicaSets. It provides flexibility when it comes to updating and managing those resources. Deployments are **declarative updates for Pods and ReplicaSets**. You describe a *desired state* and the deployment work it's way to change to that state.

Common use cases for deployments:

- Create a Deployment to rollout a ReplicaSet
- Declare the new state of the Pods
- Rollback to an earlier Deployment revision
- Scale up the Deployment to facilitate more load
- Pause the Deployment
- Use the status of the Deployment
- Clean up older ReplicaSets

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx # refers to the 
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx # refers to pods in the replicas
  template:
    metadata:
      labels:
        app: nginx # pods that will be created 
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

Deployment required Fields
- apiVersion
- kind
- metadata
- spec

kubectl create -f [file]
kubectl get deployments
kubectl get pods --show-labels
kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1 --record
kubectl edit deployment.v1.apps/nginx-deployment
kubectl describe deployments

Deployment ensures that only a certain number of Pods are down while they are being updated. By default, it ensures that at least 75% of the desired number of Pods are up (25% max unavailable).

Deployment also ensures that only a certain number of Pods are created above the desired number of Pods. By default, it ensures that at most 125% of the desired number of Pods are up (25% max surge).

### ReplicaSet

Orchestrates the individual lifecycle of Pods and updates.

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: frontend
  labels:
    app: guestbook
    tier: frontend
spec:
  # modify replicas according to your case
  replicas: 3
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: php-redis
        image: gcr.io/google_samples/gb-frontend:v3
```

### DaemonSet

The controller ensures that a single pod, of the same type, runs on every node in the cluster.
A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created.

### StatefulSet

In order to track each Pod as a unique object, the controllers uses an identity composed of stable storage, stable network identity, and an ordinal. This identity remains with the node, regardless of which node the Pod is running on at any one time.

[Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)

[ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/)

[DaemonSet](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/)

[StatefulSet](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)

# Understand how resource limits can affect Pod scheduling

When the kubelet starts a Container of a Pod, it passes the CPU and memory limits to the container runtime.

If a Container exceeds its memory limit, it might be terminated. If it is restartable, the kubelet will restart it, as with any other type of runtime failure.

If a Container exceeds its memory request, it is likely that its Pod will be evicted whenever the node runs out of memory.

A Container might or might not be allowed to exceed its CPU limit for extended periods of time. However, it will not be killed for excessive CPU usage.


[Managining Resources for Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers)
[How Pods with resource limits are run](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#how-pods-with-resource-requests-are-scheduled)
[Kubernetes Scheduler](https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/)

# Awareness of manifest management and common templating tools

Organizing resource configurations 

Using labels effectively 

kubectl get pods -Lapp -Ltier -Lrole
kubectl get pods -lapp=guestbook,role=slave
kubectl label pods -l app=nginx tier=fe
kubectl get pods -l app=nginx -L tier

Updating annotations

Sometimes you would want to attach annotations to resources. Annotations are arbitrary non-identifying metadata for retrieval by API clients such as tools, libraries, etc. This can be done with kubectl annotate. For example:


Scaling your application
kubectl scale deployment/my-nginx --replicas=1
kubectl get pods -l app=nginx

kubectl autoscale deployment/my-nginx --min=1 --max=3

In-place updates of resources
Sometimes it's necessary to make narrow, non-disruptive updates to resources you've created.

kubectl apply 
kubectl edit 

kubectl get deployment my-nginx -o yaml > /tmp/nginx.yaml
vi /tmp/nginx.yaml

kubectl patch

Disruptive updates
In some cases, you may need to update resource fields that cannot be updated once initialized, or you may want to make a recursive change immediately, such as to fix broken pods created by a Deployment. To change such fields, use replace --force, which deletes and re-creates the resource. In this case, you can modify your original configuration file:

kubectl replace -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml --force


do some edit, and then save the file

kubectl apply -f /tmp/nginx.yaml
deployment.apps/my-nginx configured

rm /tmp/nginx.yaml

[Managing Resources](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/)